# Image Kernel Processing with Serial, OpenMP, CUDA, and Hybrid Approaches

**Author:** Jayawardhana M.V.T.I  
**Index Number:** EG/2020/3996

---

## üéØ Project Overview

This project demonstrates the application of common image processing kernels using four computational approaches:

- **Serial (CPU, single-threaded)**
- **OpenMP (CPU, multi-threaded)**
- **CUDA (GPU parallelism)**
- **Hybrid (OpenMP + CUDA)**

The goal is to compare the performance of these methods and highlight the advantages of parallel computing in image processing.

---

## üñºÔ∏è Image Kernels Implemented

1. **Grayscale Conversion**  
   Converts RGB images to grayscale using a weighted sum of color channels.

2. **Gaussian Blur**  
   Applies a smoothing filter to reduce noise and detail using a convolution kernel.

3. **Sobel Edge Detection**  
   Detects edges in both X and Y directions using gradient-based convolution.

4. **Laplacian Filter**  
   Highlights regions of rapid intensity change (edges) using a Laplacian kernel.

---

## ‚öôÔ∏è Implementation Details

Each kernel is implemented in four versions:

- **Serial:**  
  Standard C code using nested loops for pixel-wise processing.

- **OpenMP:**  
  Multi-threaded CPU processing using OpenMP directives to parallelize loops.

- **CUDA:**  
  GPU-based parallelism, assigning one thread per pixel for maximum concurrency.

- **Hybrid:**  
  Combines OpenMP and CUDA: OpenMP distributes images or batches to CPU threads, each of which invokes CUDA kernels for pixel-level processing.

---

## üèóÔ∏è Directory Structure

- `serial_version/`  
  Serial C implementations for all kernels.

- `openmp_version/`  
  OpenMP-accelerated C implementations.

- `cuda_version/`  
  CUDA C/C++ implementations for GPU processing.

- `hybrid_version/`  
  Hybrid OpenMP + CUDA implementations.

- `images/`  
  Input images for testing.

- `output/`  
  Output images generated by each version.

---

## üöÄ How to Run

1. **Build the desired version** (e.g., serial, OpenMP, CUDA, or hybrid) using the provided Makefile or compile manually.
2. **Place input images** in the `images/testing_images/` directory.
3. **Run the executable** for the chosen version.  
   Output images will be saved in the corresponding `output/` subdirectory.

Example (Serial Grayscale):

```sh
cd serial_version
gcc gray_scale_filter.c -o gray_serial
./gray_serial
```

Example (OpenMP Grayscale):

```sh
cd openmp_version
gcc -fopenmp gray_scale_filter.c -o gray_omp
./gray_omp
```

Example (CUDA Grayscale):

```sh
cd cuda_version
nvcc gray_scale_filter.cu -o gray_cuda
./gray_cuda
```

---

## üìä Performance Evaluation

- **Metrics:**

  - Execution time for each kernel and version
  - Speedup compared to the serial baseline

- **Tools:**

  - Wall-clock timing using `omp_get_wtime()` and CUDA timers

- **Platform:**
  - Tested on systems with multi-core CPUs and CUDA-capable GPUs

---

## üìö References

- [OpenMP Documentation](https://www.openmp.org/)
- [CUDA Toolkit Documentation](https://docs.nvidia.com/cuda/)
- [stb_image.h / stb_image_write.h](https://github.com/nothings/stb)

---

## üìù Notes

- All code is written in C/C++.
- The project demonstrates the practical benefits of parallel programming for computationally intensive image processing tasks.
- For best results, use high-resolution images and a machine with both a multi-core CPU and a CUDA-capable GPU.

---
