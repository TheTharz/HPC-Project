<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Image Kernel Acceleration Project</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 0;
        line-height: 1.6;
        background-color: #f4f4f4;
        color: #333;
      }
      header {
        background-color: #222;
        color: #fff;
        padding: 1rem 2rem;
        text-align: center;
      }
      main {
        padding: 2rem;
        max-width: 1000px;
        margin: auto;
        background-color: #fff;
      }
      h1,
      h2 {
        color: #222;
      }
      code {
        background-color: #eee;
        padding: 0.2rem 0.4rem;
        border-radius: 4px;
      }
      section {
        margin-bottom: 2rem;
      }
      footer {
        text-align: center;
        padding: 1rem;
        background-color: #222;
        color: #fff;
        margin-top: 2rem;
      }
      .dir-structure {
        background: #f9f9f9;
        border: 1px solid #ddd;
        padding: 1rem;
        font-family: monospace;
        font-size: 0.95em;
        margin-bottom: 1.5rem;
        overflow-x: auto;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Image Kernel Processing Acceleration</h1>
      <p>
        Serial, OpenMP, CUDA, and Hybrid Approaches for Fast Image Filtering
      </p>
    </header>

    <main>
      <section>
        <h2>Project Description</h2>
        <p>
          <strong>
            A comparative study of image processing kernels implemented in C
            using Serial, OpenMP, CUDA, and Hybrid (OpenMP + CUDA) approaches.
          </strong>
          This project demonstrates grayscale conversion, Gaussian blur, Sobel
          edge detection, and Laplacian filtering on images, highlighting the
          performance benefits of parallel and GPU computing.
        </p>
      </section>

      <section>
        <h2>Author</h2>
        <p>
          <strong>Jayawardhana M.V.T.I</strong><br />
          University of Ruhuna<br />
          Index Number: EG/2020/3996
        </p>
      </section>

      <section>
        <h2>Objectives</h2>
        <ul>
          <li>Apply grayscale, blur, and edge detection filters to images</li>
          <li>
            Compare the performance of serial vs. parallel implementations
          </li>
          <li>
            Demonstrate the use of CUDA, OpenMP, and hybrid computing in
            real-world scenarios
          </li>
        </ul>
      </section>

      <section>
        <h2>Implemented Image Kernels</h2>
        <ul>
          <li>
            <strong>Grayscale Conversion:</strong> Converts RGB images to
            grayscale using a weighted sum of color channels.
          </li>
          <li>
            <strong>Gaussian Blur:</strong> Applies a smoothing filter to reduce
            noise and detail using a convolution kernel.
          </li>
          <li>
            <strong>Sobel Edge Detection:</strong> Detects edges in both X and Y
            directions using gradient-based convolution.
          </li>
          <li>
            <strong>Laplacian Filter:</strong> Highlights regions of rapid
            intensity change (edges) using a Laplacian kernel.
          </li>
        </ul>
      </section>

      <section>
        <h2>Approaches</h2>
        <ul>
          <li>
            <strong>Serial:</strong> Standard C code using nested loops for
            pixel-wise processing.
          </li>
          <li>
            <strong>OpenMP:</strong> Multi-threaded CPU processing using OpenMP
            directives to parallelize loops.
          </li>
          <li>
            <strong>CUDA:</strong> GPU-based parallelism, assigning one thread
            per pixel for maximum concurrency.
          </li>
          <li>
            <strong>Hybrid:</strong> Combines OpenMP and CUDA: OpenMP
            distributes images or batches to CPU threads, each of which invokes
            CUDA kernels for pixel-level processing.
          </li>
        </ul>
      </section>

      <section>
        <h2>Directory Structure</h2>
        <div class="dir-structure">
          serial_version/ gaussian_blur.o gray_scale_filter.o laplacian_filter.o
          sobel.o output/ gaussian/ grayscale/ laplacian/ openmp_version/
          gaussian_blur.o gray_scale_filter.o laplacian_filter.o sobel.o output/
          gaussian/ grayscale/ laplacian/ cuda_version/ gaussian_blur.o
          gray_scale_filter.o laplacian_filter.o sobel.o output/ gaussian/
          grayscale/ laplacian/ hybrid_version/ gaussian_blur.o
          gray_scale_filter.o laplacian_filter.o output/ gaussian/ grayscale/
          laplacian/ images/ testing_images/
        </div>
      </section>

      <section>
        <h2>How to Run</h2>
        <ol>
          <li>
            Build the desired version (serial, OpenMP, CUDA, or hybrid) using
            the provided Makefile or compile manually.
          </li>
          <li>
            Place input images in the
            <code>images/testing_images/</code> directory.
          </li>
          <li>
            Run the executable for the chosen version. Output images will be
            saved in the corresponding <code>output/</code> subdirectory.
          </li>
        </ol>
        <p><strong>Examples:</strong></p>
        <ul>
          <li>
            <code>cd serial_version</code><br />
            <code>gcc gray_scale_filter.c -o gray_serial</code><br />
            <code>./gray_serial</code>
          </li>
          <li>
            <code>cd openmp_version</code><br />
            <code>gcc -fopenmp gray_scale_filter.c -o gray_omp</code><br />
            <code>./gray_omp</code>
          </li>
          <li>
            <code>cd cuda_version</code><br />
            <code>nvcc gray_scale_filter.cu -o gray_cuda</code><br />
            <code>./gray_cuda</code>
          </li>
        </ul>
      </section>

      <section>
        <h2>Performance Evaluation</h2>
        <p>
          Execution time for each kernel and version is measured using
          wall-clock timers (<code>omp_get_wtime()</code> and CUDA timers).
          Results are compared to the serial baseline to demonstrate the speedup
          achieved by parallel and GPU computing.
        </p>
      </section>

      <section>
        <h2>References</h2>
        <ul>
          <li>
            <a href="https://www.openmp.org/" target="_blank"
              >OpenMP Documentation</a
            >
          </li>
          <li>
            <a href="https://docs.nvidia.com/cuda/" target="_blank"
              >CUDA Toolkit Documentation</a
            >
          </li>
          <li>
            <a href="https://github.com/nothings/stb" target="_blank"
              >stb_image.h / stb_image_write.h</a
            >
          </li>
        </ul>
      </section>

      <section>
        <h2>Project Repository</h2>
        <p>
          View the full source code and results on GitHub:<br />
          <a href="https://github.com/TheTharz/HPC-Project" target="_blank">
            github.com/TheTharz/HPC-Project
          </a>
        </p>
      </section>
    </main>

    <footer>&copy; 2025 Jayawardhana M.V.T.I â€“ All Rights Reserved</footer>
  </body>
</html>
